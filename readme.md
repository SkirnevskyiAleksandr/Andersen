## 1-lesson

1. С помощью встроенной браузерной функции prompt поочерёдно ввести два значения. Если оба значения являются валидными числами, то вывести в консоли результат в виде первого числа в системе счисления второго.
   Если хотя бы одно из введённых значений является некорректным числом, вывести в консоли сообщение: "Некорректный ввод!" и завершить программу.

   > Примеры:
   > Вводим 10 и 2, получаем 1010
   > Вводим 872 и 8, получаем 1550
   > Вводим 2 и 'abc', получаем "Некорректный ввод!"

2. С помощью встроенной браузерной функции prompt поочерёдно ввести два значения. Если первое значение является невалидным числом, вывести в консоли сообщение: "Некорректный ввод!" и завершить программу. В ином случае, если второе значение является невалидным числом вывести такое же сообщение об ошибке и завершить программу. Если оба значения являются валидными числами, то вывести в консоль результат в виде: "Ответ: [сумма двух чисел], [частное двух чисел]."
   > Примеры:
   > Вводим 10 и 2, получаем "Ответ: 12, 5."
   > Вводим 872 и 8, получаем "Ответ: 880, 109."
   > Вводим 'abc', получаем "Некорректный ввод!"

## 2-lesson

1. Написать свою функцию для глубокого копирования объектов. При этом алгоритм должен осуществляться вручную (никаких вариантов с использованием готовых библиотек или JSON.stringify() + JSON.parse(), за это сразу 0 баллов за первую задачу). Функция должна называться makeObjectDeepCopy. Это важно. Принимать функция должна один параметр - объект, копию которого нужно сделать.

2. Написать функцию, которая принимает три аргумента: массив чисел, первое значение интервала, второе значение интервала. Результатом вызова функции должен быть массив из значений переданного массива (в качестве первого параметра), которые входят в этот интервал (концы включая). Если в качестве первого параметра передан не массив или массив, содержащий не только числа - кидать ошибку (throw new Error(...)). Если хотя бы одно из значений интервала (имеются ввиду параметры функции selectFromInterval) - невалидное число!, то также кидать ошибку.
   Если первое значение интервала < второго (имеются ввиду параметры функции selectFromInterval), то считать за интервал значения от первого до второго, в ином случае - от второго до первого.
   Функция должна называться selectFromInterval.

   > Примеры:
   > Вызываем функцию: selectFromInterval([1,3,5], 5, 2)
   > Получаем результат: [3,5]
   > Вызываем функцию: selectFromInterval([-2, -15, 0, 4], -13, -5)
   > Получаем результат: []
   > Вызываем функцию: selectFromInterval(['aaa'], 2, 3)
   > Получаем результат: Ошибка!

3. Создать обычный объект и сделать его итерируемым. При этом итерация должна происходить следующим образом:
   Должны поочерёдно проходиться все значения от свойства объекта from, до свойства to. (в случае если to < from - должна возникать ошибка).
   Если to или from не указаны ИЛИ to или from не являются числами, должна возникать ошибка. Объект должен называться myIterable.
   > Примеры:
   > const myIterable = { from: 1, to: 4 };
   > for (let item of myIterable) {
   > console.log(item); // 1, 2, 3, 4
   > }

const myIterable = { from: 'aaa', to: 4 };
for (let item of myIterable) { // Ошибка!
console.log(item);
}

В новом репозитории хочу видеть ОДИН файл, в котором должны лежать (как минимум) две функции (названные правильно) и объект с реализованной итерацией (также названный правильно).
Никаких логов, алертов, комментов и т.п.

## 3-lesson

1. Написать свою реализацию встроенной функции массивов filter. Назвать функцию myFilter и сделать так, чтобы любой массив мог использовать данную функцию как "родную". В качестве параметров он должен принимать callback-функцию и как необязательный параметр объект, который будет использован в качестве this в рамках внутренних вызовов данной callback-функции.

В конечном итоге ваша реализация myFilter должна работать точно также как и встроенный метод filter. Callback-функция, переданная в качестве параметра, также должна вызываться с теми же параметрами, что и оригинал (элемент, индекс, массив).

2. Написать функцию createDebounceFunction. Она должна принимать два аргумента: callback-функцию и задержку в миллисекундах. Данная функция должна возвращать новую функцию, вызывающую callback-функцию с задержкой в переданное количество миллисекунд. ПРИ ЭТОМ! Если за то время, пока внутрення callback-функция ждёт своего вызова, наша созданная функция вызывается ещё раз, то "счётчик" времени должен сбрасываться и начинаться заново (т.е. вызова внутренней функции произойти не должно).

> Пример:
> const log100 = () => console.log(100);
> const debounceLog100 = createDebounceFunction(log100, 1000);
> debounceLog100();
> setTimeout(debounceLog100, 200); // так как задержка в 1000мс и новый вызов этой же функции происходит через 200 миллисекунд, то таймер запускается заново
> setTimeout(debounceLog100, 400); // снова сбрасываем таймер ещё через 200 миллисекунд

Вывод в консоли значения 100 примерно через 1000мс + 200мс + 200мс

## 4-lesson

1. Реализовать функцию concatStrings, которая может быть вызвана следующим образом: concatStrings('first')('second')('third')().
   Результатом вызова данной функции должна являться новая строка, содержащая все переданные таким образом строки.
   Если одно из значений является невалидной строкой (пустая строка - это валидная строка), то возвращать результат, полученный до текущего момента (ошибок не бросать!)
   Кроме этого добавить функции второй необязательный параметр - separator. Он также должен являться валидной строкой, однако в случаях, когда вместо валидной строки на его место передано что-то ещё - запускаем функцию как будто без него вообще (иными словами игнорируем, никаких ошибок кидать не нужно). Если же всё-таки параметр был валидной строкой, то результирующая строка должна содержать все переденные строки, разделённые значчением separator.

> Примеры:
> Вызываем функцию: concatStrings('first')('second')('third')()
> Получаем результат: 'firstsecondthird'
> Вызываем функцию: concatStrings('first', null)('second')()
> Получаем результат: 'firstsecond'
> Вызываем функцию: concatStrings('first', '123')('second')('third')()
> Получаем результат: 'first123second123third'
> Вызываем функцию: concatStrings('some-value')('')('')(null)
> Получаем результат: 'some-value'
> Вызываем функцию: concatStrings('some-value')(2)
> Получаем результат: 'some-value'
> Вызываем функцию: concatStrings('some-value')('333')(123n)
> Получаем результат: 'some-val333'

2. Создать класс Calculator. Конструктор класса должен принимать два валидных числа, иначе (если параметра не два или хотя бы один из них невалидный number) бросать ошибку (throw new Error('')). Данный класс должен иметь методы setX, setY, logSum, logMul, logSub, logDiv.

- setX(num) - задаёт первому из чисел новое значение. Кидать ошибку если параметр не передан или является невалидным числом;
- setY(num) - задаёт второму из чисел новое значение. Кидать ошибку если параметр не передан или является невалидным числом;
- logSum() - выводит в консоль сумму двух наших чисел внутри класса;
- logMul() - выводит в консоль произведение двух наших чисел внутри класса;
- logSub() - выводит в консоль разность двух наших чисел внутри класса;
- logDiv() - выводит в консоль частное двух наших чисел внутри класса ИЛИ кидает ошибку, если второе число (Y) равняется нулю.
  !ВАЖНО! Все методы класса должны отрабатывать корректно ДАЖЕ в случае копирования функций в отдельные переменные.

> Пример:
> const calculator = new Calculator(12, 3);
> calculator.logSum(); // 15
> calculator.logDiv(); // 4
> calculator.setX(15);
> calculator.logDiv(); // 5
> const logCalculatorDiv = calculator.logDiv;
> logCalculatorDiv(); // 5
> calculator.setY(444n); // Ошибка!

Функцию и класс называем так, как написано в задании. Проверять буду тестами.

P.s. Infinity, -Infinity и NaN - это невалидные числа (делаю такую пометку в первый и последний раз).

Задание новое, так что там есть ошибки и нужно будет ещё дополнять условия
